#!/bin/python3
# -*- coding: utf-8 -*-
"""Easily download Blender from the build bots"""

# TODO:
#   - Properly keep track of what version was already downloaded and skip it if there is no new version.
#   - Make it a more general downloader for all Blender versions, not just buildbot


import argparse
import atexit
import glob
import logging
import os
import shutil
import subprocess
import sys
import tempfile
import urllib.parse
from signal import SIGABRT, SIGINT, SIGTERM, signal

import bs4
import requests
from clint.textui import progress

if sys.platform == 'win32':
    from signal import SIGBREAK


def remove_temp_files(signal_number, stack_frame):
    """Signal handler to remove lingering temp files."""
    blender_archive = os.environ.get('BLENDER_ARCHIVE')
    if blender_archive and os.path.isfile(blender_archive):
        sys.stdout.write(f"\nCleaning temp file '{blender_archive}'...\n")
        try:
            os.remove(blender_archive)
        except OSError:
            sys.stderr.write(f"Removing file '{blender_archive}' failed."
                             "\n{traceback.format_exc()}\n")
    sys.exit(signal_number)


def download_file(url, destination_dir):
    """Download a file from the specified url

    The code is based on this:
    https://stackoverflow.com/questions/16694907/how-to-download-large-file-in-python-with-requests-py#16696317

    Args:
        url (str): The url for the file
        destination_dir (str or None): Where to save the file
    """
    local_filename = url.split('/')[-1]
    if not os.path.isdir(destination_dir):
        os.makedirs(destination_dir)
    destination = os.path.join(destination_dir, local_filename)
    response = requests.get(url, stream=True)
    with open(destination, 'wb') as f:
        total_length = int(response.headers.get('content-length'))
        for chunk in progress.bar(
                response.iter_content(chunk_size=1024),
                label="Download progress ",
                expected_size=(total_length / 1024) + 1,
        ):
            if chunk:
                f.write(chunk)
    return destination


class Downloader:
    buildbot_url = "https://builder.blender.org"
    download_page_url = "https://builder.blender.org/download"
    platform_mapping = {
        'linux': 'linux',
        'darwin': 'macos',
        'win32': 'windows',
    }
    platform_download_mapping = {
        'linux-64': 'Linux 64 bit',
        'macos-64': 'macOS 64 bit',
        'windows-64': 'Windows 64 bit',
    }
    # blender_version_mapping = {
    #     '2.79': 'blender2.7',
    #     '2.80': 'master',
    # }
    pip_packages = [
        # "psd-tools",
        # "Pillow",
        # "sqlalchemy",
        # "alembic",
        # "jinja2",
        # "psycopg2",
        # "pytz",
        "PySide2",
    ]

    # getpipfile = os.path.expanduser("~/src/blender-git/get-pip.py")

    def __init__(
            self,
            platform,
            download_dir,
            version=None,
            arch="64",
            extract=False,
            pip_install=False,
            debug=False,
    ):
        """Download the Blender version specified

        Args:
            version (str): The version to download
            platform (str): For which platform to download Blender
            arch (str): Download 32 or 64 bit version
            download_dir (str): The directory to download Blender to
        """
        self.blender_version = version
        self.python_version = None
        self._platform = platform
        self.arch = arch
        self.destination_dir = self._validate_destination_dir(download_dir)
        self.extract = extract
        self.pip_install = pip_install
        self.blender_archive = None
        self.logger = logging.getLogger('blender_downloader')
        if debug:
            self.logger.setLevel(logging.DEBUG)
        else:
            self.logger.setLevel(logging.INFO)
        self.logger.addHandler(logging.StreamHandler())

    @property
    def platform(self):
        if self._platform is None:
            if sys.platform.startswith('linux'):
                return 'linux'
            platform = self.platform_mapping.get(sys.platform)
            if platform is None:
                self.logger.warning("Platform %s is not supported", sys.platform)
            return platform

    @platform.setter
    def platform(self, platform):
        if platform not in ['linux', 'macos', 'windows']:
            self.logger.warning("Platform %s is not supported", sys.platform)
            self._platform = None
        else:
            self._platform = platform

    @staticmethod
    def _validate_destination_dir(destination_dir):
        """Validate the destination_dir"""
        return destination_dir or tempfile.gettempdir()

    def _get_download_link(self):
        """Get the download link"""
        download_page = requests.get(self.download_page_url)
        download_page.raise_for_status()
        soup = bs4.BeautifulSoup(download_page.content, 'lxml')
        full_platform = '-'.join((self.platform, self.arch))
        operating_system = self.platform_download_mapping[full_platform]
        # version = self.blender_version_mapping[self.blender_version]
        # ga_label = f'{operating_system} {version}'
        ga_label = f'{operating_system} build'

        download_link = soup.find('a', {'class': 'js-ga', 'ga_label': ga_label}).get('href')
        # if self.blender_version in download_link:
        return urllib.parse.urljoin(self.buildbot_url, download_link)

    @staticmethod
    def _ensure_exec(executable):
        """Ensure a file has executable permissions"""
        # Problem is only on macOS so skip this for other OSes.
        if sys.platform == 'darwin':
            # TODO: only add +x for owner and not hard coded full permissions as now.
            os.chmod(executable, 744)

    @staticmethod
    def _fix_ssl(python_exec):
        """Fix the SSL module"""
        if sys.platform != 'darwin':
            return True
        src = ('/Library/Frameworks/Python.framework/Versions/3.6/lib/'
               'python3.7/lib-dynload/_ssl.cpython-37m-darwin.so')
        dst = os.path.join(
            os.path.dirname(python_exec),
            '..',
            'lib',
            'python3.7',
            'lib-dynload',
            '_ssl.cpython-36m-darwin.so',
        )
        dst = os.path.normpath(dst)
        shutil.copy2(src, dst)
        return True

    @staticmethod
    def _fix_dynload(python_exec):
        """Fix the libraries in the lib-dynload directory"""
        if sys.platform != 'darwin':
            return True
        src = ('/Library/Frameworks/Python.framework/Versions/3.7/lib/' 'python3.7/lib-dynload')
        dst = os.path.join(os.path.dirname(python_exec), '..', 'lib', 'python3.7', 'lib-dynload')
        dst = os.path.normpath(dst)
        shutil.rmtree(dst)
        shutil.copytree(src, dst)
        return True

    def _check_ssl(self, python_exec, fix=False):
        """Check the SSL module

        Check if the SSL module is correctly installed. If not try to fix it.

        Args:
            python_exec (str): The path to the python executable.

        Returns:
            bool: True if SSL is installed correctly, False otherwise.
        """
        return_value = subprocess.call([
            python_exec,
            '-c',
            '"import ssl"',
        ])
        if return_value != 0:
            self.logger.debug("SSL is not properly installed.")
            if fix:
                self.logger.debug("Running _fix_ssl")
                if not self._fix_ssl(python_exec):
                    return False
            else:
                return False
        return True

    def _remove_pip_module(self, datafiles_dir):
        """Remove pip from site-packages."""
        sitepackages_dir = os.path.join(
            datafiles_dir,
            'python',
            'lib',
            'python3.7',
            'site-packages',
        )
        if os.path.isdir(os.path.join(sitepackages_dir, 'pip')):
            self.logger.debug('Installed pip module found, removing...')
            pipdirs = glob.glob(os.path.join(sitepackages_dir, 'pip*'))
            for pipdir in pipdirs:
                shutil.rmtree(os.path.join(sitepackages_dir, pipdir))

    def _install_pip(self, extra_packages=False, blender_dir=None):
        """Install pip and additional packages (optional).

        Args:
            extra_packages (bool): whether to install extra packages
            blender_dir (None or str): where blender is installed
        """
        if blender_dir is None:
            self.logger.error("The blender directory is not specified.")
            sys.exit(1)
        if not os.path.isdir(blender_dir):
            self.logger.error("The blender directory doesn't exist: %s", blender_dir)
            sys.exit(1)
        if sys.platform == 'darwin':
            datafiles_dir = os.path.join(
                blender_dir,
                "blender.app",
                "Contents",
                "Resources",
                self.blender_version,
            )
        else:
            datafiles_dir = os.path.join(blender_dir, self.blender_version)
        # if not os.path.isfile(self.getpipfile):
        #     self.logger.error("Couldn't find %s. Not installing pip.",
        #                       self.getpipfile)
        #     sys.exit(1)
        python_exec = os.path.join(datafiles_dir, "python", "bin", "python3.7m")
        self._ensure_exec(python_exec)
        # FIXME: It seems this is not needed anymore.
        # if not self._fix_ssl(python_exec):
        #     self.logger.error("Couldn't install pip. SSL was not correctly "
        #                       "installed and could not be fixed.")
        #     sys.exit(1)
        # TODO: seems this is not needed anymore
        # if not self._fix_dynload(python_exec):
        #     self.logger.error("Couldn't fix the lib-dynload libraries.")
        #     sys.exit(1)
        # FIXME: pip is now installed as a module so the installation of pip
        #        will not continue as the pip executable is not available.
        #        Remove pip from site-packages first, so install will work.
        #        See if there is a better way to do this.
        self._remove_pip_module(datafiles_dir)
        self.logger.info("Installing pip...")
        # return_value = subprocess.call([
        #     python_exec,
        #     self.getpipfile,
        #     '--ignore-installed',
        # ])
        process = subprocess.Popen(
            [
                python_exec,
                '-m',
                'ensurepip',
                '--default-pip',
                '--upgrade',
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = process.communicate()
        return_value = process.returncode
        if return_value == 0:
            self.logger.info("Successfully installed pip.")
            self.logger.debug(stdout)
            process = subprocess.Popen([
                os.path.join(datafiles_dir, "python", "bin", "pip"),
                "install",
                "--upgrade",
                "pip",
            ])
            stdout, stderr = process.communicate()
            return_value = process.returncode
            if return_value == 0:
                self.logger.info("Successfully upgraded pip.")
                self.logger.debug(stdout)
            else:
                self.logger.error("Upgrading pip failed.")
                self.logger.debug(stderr)
                sys.exit(1)
        else:
            self.logger.error("Couldn't install pip. There was an error.")
            self.logger.debug(stderr)
            sys.exit(1)
        if extra_packages:
            pip_args = [
                os.path.join(datafiles_dir, "python", "bin", "pip"),
                "install",
            ]
            pip_args.extend(self.pip_packages)
            return_value = subprocess.call(pip_args)
            if return_value == 0:
                self.logger.info("Successfully installed %s", ", ".join((self.pip_packages)))
            else:
                self.logger.error(
                    "There was an error during the installation of the external packages.")
                sys.exit(1)

    def _extract_blender(self):
        """Extract the downloaded archive"""
        # TODO: specify where to extract
        archive_file = self.blender_archive
        if not os.path.isfile(archive_file):
            self.logger.error("File not found: %s", archive_file)
            sys.exit(1)
        if sys.platform == 'darwin':
            destination_dir = '/Applications/blender-buildbot'
        else:
            destination_dir = os.path.expanduser('~/blender-buildbot')
        if os.path.exists(destination_dir):
            shutil.rmtree(destination_dir)
        self.logger.info("Extracting to %s", destination_dir)
        basename, ext = os.path.splitext(os.path.basename(archive_file))
        if ext.lower() == ".zip":
            import zipfile
            archive = zipfile.ZipFile(archive_file)
            archive.extractall(path=tempfile.gettempdir())
        else:
            import tarfile
            with tarfile.open(archive_file) as archive:
                archive.extractall(path=tempfile.gettempdir())
        if ext.lower() == '.bz2':
            basename = os.path.splitext(basename)[0]
        basename = basename.rsplit('-', 4)[0]
        # FIXME
        blender_dir = [
            d for d in os.listdir(tempfile.gettempdir())
            if os.path.isdir(os.path.join(tempfile.gettempdir(), d)) and basename in d
        ][0]
        extract_dir = os.path.join(tempfile.gettempdir(), blender_dir)
        shutil.move(extract_dir, destination_dir)
        os.remove(archive_file)
        if self.pip_install:
            self._install_pip(extra_packages=True, blender_dir=destination_dir)
        if sys.platform == 'darwin':
            blender_exec = os.path.join(
                destination_dir,
                "blender.app",
                "Contents",
                "MacOS",
                "blender",
            )
            self._ensure_exec(blender_exec)

    def download_blender(self):
        """Download Blender from https://builder.blender.org"""
        link = self._get_download_link()
        if link is None:
            self.logger.warning("Couldn't find the download link. Aborting...")
            sys.exit(1)
        destination = os.path.join(self.destination_dir, link.split('/')[-1])
        os.environ['BLENDER_ARCHIVE'] = destination
        answer = 'y'
        if os.path.isfile(destination):
            answer = input(f"File '{destination} already exists. Overwrite it (Y/n)?")
        if answer != 'n':
            self.logger.info("Downloading %s", link)
            self.blender_archive = download_file(link, destination_dir=self.destination_dir)
        else:
            self.logger.info("Skipping download, because the file already exists %s", destination)
        if self.blender_archive and os.path.isfile(self.blender_archive):
            BLENDER_ARCHIVE = self.blender_archive
            self.logger.info("Downloaded %s to %s", link, self.blender_archive)
        else:
            self.logger.error("Wasn't able to download Blender")
            sys.exit(1)
        if self.extract:
            self._extract_blender()
        self.logger.info("Done!")


def main():
    """Main function."""
    logger = logging.getLogger('download_blender_buildbot')
    parser = argparse.ArgumentParser(description='Download BEB (Bleeding Edge Blender)')
    # parser.add_argument(
    #     '--blender-version',
    #     choices=['2.79', '2.80'],
    #     default='2.79',
    #     help='the version of Blender you want to download',
    # )
    parser.add_argument(
        '--platform',
        choices=['linux', 'macos', 'windows'],
        # default='linux',
        help='for which platform to download Blender',
    )
    parser.add_argument(
        '--download-dir',
        dest='downloaddir',
        help='where to download Blender to',
    )
    parser.add_argument(
        '--extract',
        action='store_true',
        default=False,
        help='extract the downloaded archive',
    )
    parser.add_argument(
        '--pip-install',
        action='store_true',
        default=False,
        help='install pip and some external packages',
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        default=False,
        help='Log debug messages',
    )
    args = parser.parse_args()
    downloader = Downloader(
        platform=args.platform,
        download_dir=args.downloaddir,
        # version=args.blender_version,
        # arch=args.arch,
        extract=args.extract,
        pip_install=args.pip_install,
        debug=args.debug,
    )
    downloader.download_blender()


if __name__ == "__main__":
    # atexit.register(remove_temp_files)
    signals = [SIGABRT, SIGINT, SIGTERM]
    if sys.platform == 'win32':
        signals.append(SIGBREAK)
    for sig in signals:
        signal(sig, remove_temp_files)
    main()
