#!/bin/bash

# Settings
declare -a LIST_OF_WM_CLASSES_THAT_PREVENT_LOCKING=(
    "Pinentry-gtk-2" "Jitsi Meet"
)
declare -a LIST_OF_WM_CLASSES_THAT_PREVENT_LOCKING_FULLSCREEN=(
    "mpv" "Wine" "vlc" "Pinentry-gtk-2"
)
declare -a LIST_OF_WINDOW_TITLES_THAT_PREVENT_LOCKING_FULLSCREEN=(
    "NPO" "YouTube" "Netflix" "Prime Video" "Jitsi Meet"
)

declare -a LOCK_IMAGES

# Find active window id
get_active_id() {
    xprop -root | awk '$1 ~ /_NET_ACTIVE_WINDOW/ { print $5 }'
}

# Find active window WM_CLASS
get_wm_class() {
    xprop -id $1 | awk -F '=' '$1 ~ /WM_CLASS\(STRING\)/ { print $2 }' | cut -d "," -f 2 | tr -d '[:space:]'
}

# Determine a window's title text by it's ID
get_window_title() {
    # For mplayer or vlc, we might need to check WM_CLASS(STRING), idk.
    xprop -id $1 | awk -F '=' '$1 ~ /_NET_WM_NAME\(UTF8_STRING\)/ { print $2 }'
}

# Determine if a window is fullscreen based on it's ID
is_fullscreen() {
    xprop -id $1 | awk -F '=' '$1 ~ /_NET_WM_STATE\(ATOM\)/ { if ($2 ~ /STATE_FULLSCREEN/) exit 0; exit 1 }'
    return $?
}

# Determine if the locker command should run based on which windows are fullscreened.
should_lock() {
    id=$(get_active_id)
    wmclass=$(get_wm_class $id)
    title=$(get_window_title $id)

    if is_fullscreen $id; then
        for i in "${LIST_OF_WM_CLASSES_THAT_PREVENT_LOCKING_FULLSCREEN[@]}"; do
            if [[ $wmclass =~ $i ]]; then
                return 1
            fi
        done
        for i in "${LIST_OF_WINDOW_TITLES_THAT_PREVENT_LOCKING_FULLSCREEN[@]}"; do
            if [[ $title =~ $i ]]; then
                return 1
            fi
        done
    fi
    for i in "${LIST_OF_WM_CLASSES_THAT_PREVENT_LOCKING[@]}"; do
        if [[ $wmclass =~ $i ]]; then
            return 1
        fi
    done
}

# Create one big image spanning all monitors
create_monitor_spanning_image() {
    lock_image="$(find $HOME/[Pp]ictures/backgrounds/lock -maxdepth 1 -iname '*.png' -type f | shuf -n 1)"
    monitors_size_pos=$(xrandr --listactivemonitors | awk -F ' ' '/^\s[[:digit:]]:\s/ {print $3}' | \
        sed -nE "s|^([[:digit:]]+)/[[:digit:]]+x([[:digit:]]+)/[[:digit:]]+\+([[:digit:]]+)\+([[:digit:]]+)|\1x\2+\3+\4|p")
    while IFS= read -r line; do
        x=$(echo $line | cut -dx -f1)
        y=$(echo $line | cut -dx -f2 | cut -d+ -f1)
        offset_x=$(echo $line | cut -d+ -f2)
        offset_y=$(echo $line | cut -d+ -f3)
        random_string=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 8)
        image="/tmp/lock_image_$random_string-$offset_x-$offset_y.png"
        convert -geometry $x"x" $lock_image $image
        LOCK_IMAGES+=($image)
    done <<< "$monitors_size_pos"

    # Construct the convert command
    convert_command="convert"
    for image in ${LOCK_IMAGES[@]}; do
        filename=$(basename -- "$image")
        filename=${filename%.*}
        offset=$(echo $filename | awk -F '-' '{print "+"$2"+"$3}')
        convert_command="$convert_command -page $offset $image"
    done

    convert_command="$convert_command -background gray10 -layers merge /tmp/lock.png"

    # Run the convert command
    eval $convert_command

    # Delete the individual images
    # rm ${LOCK_IMAGES[@]}

}

# lock() {
#     if should_lock; then
#         i3lock --ignore-empty-password --show-failed-attempts --tiling \
#             --image "$(find $HOME/[Pp]ictures/backgrounds/lock -maxdepth 1 -iname *.png -type f | shuf -n 1)"
#         sleep 1
#     fi
# }

lock() {
    if should_lock; then
        # pause dunst
        # TODO: check if this new attempt at pausing dunst actually works
        export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus; export DISPLAY=:0; notify-send DUNST_COMMAND_PAUSE

        # Check for multi-monitor setup
        # TODO: Only create 1 image if resolutions of monitors differ
        # external_monitor=$(xrandr | sed -nE "s/^((DP|HDMI)-[0-9]+) connected.*$/\1/p")
        if [[ $(xrandr --listactivemonitors | wc -l) -gt 2 ]]; then
            create_monitor_spanning_image
            i3lock --ignore-empty-password --show-failed-attempts --tiling \
                --image /tmp/lock.png
            # # take screenshot
            # scrot -m /tmp/screenshot.png
            # # blur it
            # convert /tmp/screenshot.png -blur 0x20 /tmp/lockblur.png
            # rm /tmp/screenshot.png
            # # lock
            # i3lock --ignore-empty-password --show-failed-attempts --tiling \
            #     --image /tmp/screenshotblur.png
        else
            lock_image="$(find $HOME/[Pp]ictures/backgrounds/lock -maxdepth 1 -iname '*.png' -type f | shuf -n 1)"
            i3lock --ignore-empty-password --show-failed-attempts --tiling \
                --image "$lock_image"
        fi
        sleep 1
        # resume dunst
        export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus; export DISPLAY=:0; notify-send DUNST_COMMAND_RESUME
    fi
}

case "$1" in
    lock)
        lock
        ;;
    logout)
        i3 exit
        ;;
    suspend)
        lock && systemctl suspend
        ;;
    hibernate)
        lock && systemctl hibernate
        ;;
    reboot)
        systemctl reboot
        ;;
    shutdown)
        systemctl poweroff
        ;;
    *)
        echo "Usage: $0 {lock|logout|suspend|hibernate|reboot|shutdown}"
        exit 2
esac

exit 0
